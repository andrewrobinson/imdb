
	// https://www.yellowduck.be/posts/graceful-shutdown/
	// https://www.yellowduck.be/posts/waitgroup-channels/
	// https://medium.com/code-zen/concurrency-in-go-5fcba11acb0f
	// https://stackoverflow.com/questions/36056615/what-is-the-advantage-of-sync-waitgroup-over-channels




var urls map[string]string = make(map[string]string)

urls["tt0000001"] = "http://localhost:3000/static/tt0000075.json"
urls["tt0000002"] = "http://localhost:3000/static/tt0000075.json"
urls["tt0000003"] = "http://localhost:3000/static/tt0000075.json"
urls["tt0000004"] = "http://localhost:3000/static/tt0000075.json"
urls["tt0000005"] = "http://localhost:3000/static/tt0000075.json"

var plots map[string]string = make(map[string]string)

results := plot.BoundedParallelGet(urls, 10)

for _, result := range results {

	var p IMResponse

	err := json.NewDecoder(result.Res.Body).Decode(&p)
	if err != nil {
		log.Fatalln(err)

	}
	plots[result.Tconst] = p.Plot

}

fmt.Printf("plots:%+v", plots)






// we'll use the init function to set up the benchmark
// by making a map of 100 URLs to send requets to
// var urls map[string]string = make(map[string]string)

// func init() {

// 	urls["tt0000001"] = "http://localhost:3000/static/tt0000075.json"
// 	urls["tt0000002"] = "http://localhost:3000/static/tt0000075.json"
// 	urls["tt0000003"] = "http://localhost:3000/static/tt0000075.json"
// 	urls["tt0000004"] = "http://localhost:3000/static/tt0000075.json"
// 	urls["tt0000005"] = "http://localhost:3000/static/tt0000075.json"

// }

// the main function sets up an anonymous benchmark func
// that will time how long it takes to get all the URLs
// at the specified concurrency level
//
// and you should see something like the following printed
// depending on how fast your computer and internet is
//
// 5 bounded parallel requests: 100/100 in 5.533223255
// 10 bounded parallel requests: 100/100 in 2.5115351219
// 25 bounded parallel requests: 100/100 in 1.189462884
// 50 bounded parallel requests: 100/100 in 1.17430002
// 75 bounded parallel requests: 100/100 in 1.001383863
// 100 bounded parallel requests: 100/100 in 1.3769354

type IMResponse struct {
	Plot string
}

func main() {

	var urls map[string]string = make(map[string]string)

	urls["tt0000001"] = "http://localhost:3000/static/tt0000075.json"
	urls["tt0000002"] = "http://localhost:3000/static/tt0000075.json"
	urls["tt0000003"] = "http://localhost:3000/static/tt0000075.json"
	urls["tt0000004"] = "http://localhost:3000/static/tt0000075.json"
	urls["tt0000005"] = "http://localhost:3000/static/tt0000075.json"

	var plots map[string]string = make(map[string]string)

	results := plot.BoundedParallelGet(urls, 10)

	for _, result := range results {

		var p IMResponse

		err := json.NewDecoder(result.Res.Body).Decode(&p)
		if err != nil {
			log.Fatalln(err)

		}
		plots[result.Tconst] = p.Plot

	}

	fmt.Printf("plots:%+v", plots)

	// fmt.Sprintf("results:%+v", results)

	// benchmark := func(urls map[string]string, concurrency int) string {
	// 	startTime := time.Now()
	// 	results := plot.BoundedParallelGet(urls, concurrency)
	// 	seconds := time.Since(startTime).Seconds()
	// 	tmplate := "%d bounded parallel requests: %d/%d in %v, results:%+v"

	// 	// fmt.Sprintf("results:%v", results)

	// 	return fmt.Sprintf(tmplate, concurrency, len(results), len(urls), seconds, results)
	// }

	// fmt.Println(benchmark(urls, 10))
	// // fmt.Println(benchmark(urls, 25))
	// // fmt.Println(benchmark(urls, 50))
	// // fmt.Println(benchmark(urls, 75))
	// fmt.Println(benchmark(urls, 100))
}
